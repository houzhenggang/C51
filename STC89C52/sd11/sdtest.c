#include<reg52.h>
#include "Serial.h" 
#define uchar unsigned char
#define uint unsigned int
#define ulon unsigned long

sbit CLK=P3^4;
sbit DI=P3^5;
sbit DO=P3^6;
sbit CS=P3^7;

void Display(uchar);
void SPI_W(uchar);
uchar SPI_R();
uchar SD_Response();
void SD_Cmd(uchar,ulon,uchar);
uchar SD_Init();
uchar SD_Block_W(uchar,ulon,uint);
uchar* SD_Block_R(ulon,uint);
uchar xdata *DATA;

uchar code Test_1[]={
	0x83, 0x7E, 0x57, 0x24, 0x0E, 0x3A, 0x68, 0x89, 0x87, 0x87, 0xA7, 0xBE, 0xBB, 0x94, 0x65, 0x31, 
	0x00, 0x2F, 0x7C, 0xA8, 0x97, 0x64, 0x62, 0x7A, 0xA5, 0xBE, 0xA6, 0x94, 0x6D, 0x50, 0x25, 0x47, 
	0x5F, 0x77, 0x74, 0x7C, 0x7B, 0x82, 0x9E, 0xB8, 0xBD, 0xA7, 0x7E, 0x4F, 0x00, 0x14, 0x6A, 0x93, 
	0xA4, 0x6D, 0x5A, 0x6A, 0x83, 0xB8, 0xAB, 0x97, 0x7E, 0x5A, 0x07, 0x23, 0x6B, 0xA1, 0x95, 0x62, 
	0x61, 0x80, 0xA0, 0xAA, 0xBF, 0xBC, 0xBF, 0x99, 0x51, 0x26, 0x81, 0xA7, 0xB0, 0x77, 0x62, 0x70, 
	0x91, 0xA6, 0xA8, 0xAE, 0xB5, 0xC3, 0xA4, 0x61, 0x16, 0x5D, 0x93, 0xB2, 0x95, 0x6E, 0x71, 0x94, 
	0xB0, 0xB6, 0xB8, 0xAD, 0xA9, 0x90, 0x61, 0x03, 0x52, 0xAE, 0xD3, 0xB4, 0x7D, 0x7D, 0x98, 0xAE, 
	0xA3, 0xBA, 0xC1, 0xC4, 0xAC, 0x6B, 0x00, 0x2E, 0x9B, 0xDA, 0xCF, 0x8E, 0x90, 0xA8, 0xC5, 0xC1, 
	0xB4, 0xA6, 0xA3, 0x9F, 0x86, 0x3A, 0x4C, 0x95, 0xC8, 0xD8, 0xA4, 0x93, 0x92, 0xAC, 0xB6, 0xA3, 
	0x98, 0xAE, 0xCE, 0xBB, 0x85, 0x22, 0x69, 0xA3, 0xD4, 0xC4, 0x91, 0x8D, 0x9B, 0xA4, 0x90, 0x94, 
	0xBA, 0xD6, 0xD0, 0x9B, 0x52, 0x4F, 0x98, 0xC8, 0xE0, 0xA1, 0x9C, 0x95, 0x92, 0x7F, 0xA6, 0xD5, 
	0xE9, 0xE2, 0xAE, 0x85, 0x39, 0x84, 0xBA, 0xD6, 0xB1, 0x98, 0x81, 0x7D, 0x8C, 0xAE, 0xD2, 0xDD, 
	0xD2, 0xB5, 0x9A, 0x5E, 0x64, 0x94, 0xAD, 0xC0, 0x9C, 0x93, 0x8F, 0x97, 0xA6, 0xC4, 0xD8, 0xC9, 
	0xC0, 0xA2, 0x8A, 0x5C, 0x7F, 0x99, 0xA8, 0xA0, 0x90, 0x86, 0x7C, 0x98, 0xD3, 0xDB, 0xC9, 0xA7, 
	0x8B, 0x82, 0x71, 0x75, 0x81, 0x81, 0x8D, 0x85, 0x89, 0x93, 0xA2, 0xB0, 0xBB, 0xB5, 0xAA, 0xA2, 
	0x96, 0x7E, 0x65, 0x7F, 0x8E, 0x97, 0x83, 0x82, 0x77, 0x89, 0x9A, 0xBE, 0xBD, 0xB8, 0xA3, 0x8D
};
//
uchar code Test_2[]={
	0xFE, 0xAF, 0xBD, 0xFA, 0xAA, 0xBB, 0xCD, 0x89, 0x87, 0x87, 0xA7, 0xBE, 0xBB, 0x94, 0x65, 0x31, 
	0x00, 0x2F, 0x7C, 0xA8, 0x97, 0x64, 0x62, 0x7A, 0xA5, 0xBE, 0xA6, 0x94, 0x6D, 0x50, 0x25, 0x47, 
	0x5F, 0x77, 0x74, 0x7C, 0x7B, 0x82, 0x9E, 0xB8, 0xBD, 0xA7, 0x7E, 0x4F, 0x00, 0x14, 0x6A, 0x93, 
	0xA4, 0x6D, 0x5A, 0x6A, 0x83, 0xB8, 0xAB, 0x97, 0x7E, 0x5A, 0x07, 0x23, 0x6B, 0xA1, 0x95, 0x62, 
	0x61, 0x80, 0xA0, 0xAA, 0xBF, 0xBC, 0xBF, 0x99, 0x51, 0x26, 0x81, 0xA7, 0xB0, 0x77, 0x62, 0x70, 
	0x91, 0xA6, 0xA8, 0xAE, 0xB5, 0xC3, 0xA4, 0x61, 0x16, 0x5D, 0x93, 0xB2, 0x95, 0x6E, 0x71, 0x94, 
	0xB0, 0xB6, 0xB8, 0xAD, 0xA9, 0x90, 0x61, 0x03, 0x52, 0xAE, 0xD3, 0xB4, 0x7D, 0x7D, 0x98, 0xAE, 
	0xA3, 0xBA, 0xC1, 0xC4, 0xAC, 0x6B, 0x00, 0x2E, 0x9B, 0xDA, 0xCF, 0x8E, 0x90, 0xA8, 0xC5, 0xC1, 
	0xB4, 0xA6, 0xA3, 0x9F, 0x86, 0x3A, 0x4C, 0x95, 0xC8, 0xD8, 0xA4, 0x93, 0x92, 0xAC, 0xB6, 0xA3, 
	0x98, 0xAE, 0xCE, 0xBB, 0x85, 0x22, 0x69, 0xA3, 0xD4, 0xC4, 0x91, 0x8D, 0x9B, 0xA4, 0x90, 0x94, 
	0xBA, 0xD6, 0xD0, 0x9B, 0x52, 0x4F, 0x98, 0xC8, 0xE0, 0xA1, 0x9C, 0x95, 0x92, 0x7F, 0xA6, 0xD5, 
	0xE9, 0xE2, 0xAE, 0x85, 0x39, 0x84, 0xBA, 0xD6, 0xB1, 0x98, 0x81, 0x7D, 0x8C, 0xAE, 0xD2, 0xDD, 
	0xD2, 0xB5, 0x9A, 0x5E, 0x64, 0x94, 0xAD, 0xC0, 0x9C, 0x93, 0x8F, 0x97, 0xA6, 0xC4, 0xD8, 0xC9, 
	0xC0, 0xA2, 0x8A, 0x5C, 0x7F, 0x99, 0xA8, 0xA0, 0x90, 0x86, 0x7C, 0x98, 0xD3, 0xDB, 0xC9, 0xA7, 
	0x8B, 0x82, 0x71, 0x75, 0x81, 0x81, 0x8D, 0x85, 0x89, 0x93, 0xA2, 0xB0, 0xBB, 0xB5, 0xAA, 0xA2, 
	0x96, 0x7E, 0x65, 0x7F, 0x8E, 0x97, 0x83, 0x82, 0x77, 0x89, 0x9A, 0xBE, 0xBD, 0xB8, 0xA3, 0x8D,
};
//
void main()
{
	uint i=0,j;
	ulon const Lenth=512;//数据块长度
	SD_Init();	//SD卡初始化
	SerialInit();//
	//LCDInit();
	SD_Block_W(Test_1,Lenth*100,Lenth);//往地址51200处写测试数据
	SD_Block_W(Test_2,Lenth*100+512,Lenth);//往地址51200处写测试数据
	//
	DATA=SD_Block_R(Lenth*100,Lenth);
	//
	while(1)
	{
		for(i=0;i<512;i++)
		{
			P1=DATA[i];
			SerialPutString(&DATA[i]);
		}
	}
}
/***************************************
*                 显示函数
*****************************************/
void Display(uchar Num)
{
	//uchar 
}
/***************************************
*                 SPI写函数
*****************************************/
void SPI_W(uchar Data)
{
	uchar i;
	for(i=0;i<8;i++)
	{
		Data<<=1;
		CLK=0;
		DI=CY;
		CLK=1;
	}
	DI=1;
}
/***************************************
*                 SPI读函数
*****************************************/
uchar SPI_R()
{
	uchar Data,i;
	DO=1;

	for(i=0;i<8;i++)
	{
		Data<<=1;
		CLK=0;
		CLK=1;
		Data|=DO;
	}
	return Data;
}
/***************************************
*                 读SD卡函数
*****************************************/
uchar SD_Response()
{
	uchar i,Response;

	for(i=0;i<10;i++)
	{
		Response=SPI_R();
		if(Response==0x00)
			break;
		if(Response==0x01)
			break;
	}
	return Response;
}
/***************************************
*                 向SD卡写命令
*****************************************/
void SD_Cmd(uchar Cmd,ulon Argument,uchar CRC)
{
	uchar arg[4];

	arg[0]=(uchar)Argument;
	arg[1]=(uchar)(Argument>>8);
	arg[2]=(uchar)(Argument>>16);
	arg[3]=(uchar)(Argument>>24);
	//
	SPI_W(Cmd|0x40);
	SPI_W(arg[3]);
	SPI_W(arg[2]);
	SPI_W(arg[1]);
	SPI_W(arg[0]);
	SPI_W(CRC);
}
/***************************************
*                 SD卡初始化函数
*****************************************/
uchar SD_Init()
{
	uint delay=0,trials=0;
	uchar i;
	uchar Response=0xff;
	//
	CS=1;
	for(i=0;i<10;i++)
		SPI_W(0xff);
	CS=0;
	//
	SD_Cmd(0x00,0,0x95);
	//
	i=0;
	while(SD_Response()!=0x01)
	{
		i++;
		if(i>=100)
			return 0;
	}
	//
	CS=1;
	SPI_W(0xff);
	//
	i=0;
	CS=0;
	while(Response!=0x00)
	{
		SD_Cmd(0x01,0,0xff);
		//
		Response=SD_Response();
		i++;
		if(i>100)
			return 0;
	}
	//
	CS=1;
	SPI_W(0xff);
	return 1;
}
/***************************************
*                 SD卡数据写入函数
*****************************************/
uchar SD_Block_W(uchar *Block,ulon address,uint len)
{
	uint i;
	uchar Respose_Write;
	P1=0xff;
	CS=0;
	SD_Cmd(0x18,address,0xff);
	//
	while(Respose_Write!=0x00)
	{
		P1=Block[i];
		for(i=0;i<10;i++)
			SPI_W(0xff);
		//
		SPI_W(0xfe);
		//
		for(i=0;i<len;i++)
			SPI_W(Block[i]);
		SPI_W(0xff);
		SPI_W(0xff);
		//
		Respose_Write=SPI_R()&0x0f;
		while(SPI_R()==0);
		CS=1;
		SPI_W(0xff);
		//
		if(Respose_Write==0x05)
			return 1;
		else
			return 0;
	}
}
/***************************************
*                 SD卡读数据块函数
*****************************************/
uchar* SD_Block_R(ulon address,uint len)
{
	uint i;
	uchar xdata Block[512];
	SD_Cmd(0x11,address,0xff);
	//
	while(SD_Response()!=0x00);
	while(SPI_R()!=0xfe);
	//
	for(i=0;i<len;i++)
		Block[i]=SPI_R();
	SPI_R();
	SPI_R();

	CS=1;
	SPI_R();

	return Block;
}
